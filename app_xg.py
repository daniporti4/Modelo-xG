# -*- coding: utf-8 -*-
"""app_xG.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/155aDzN1xZLSOGu_wgLtDzAxF9Daup2dK
"""


import streamlit as st
import pandas as pd
import numpy as np
import joblib
from xgboost import XGBRegressor
from streamlit_drawable_canvas import st_canvas
from PIL import Image


# Cargar modelo y encoder
modelo = joblib.load("modelo_prueba.pkl")
encoder = joblib.load("encoder_ohe.pkl")

st.title("Calculadora de xG")

# Columnas categóricas en orden
categorical_cols = [
    'shot_body_part', 'play_pattern', 'under_pressure',
    'shot_one_on_one', 'shot_open_goal', 'shot_aerial_won',
    'shot_first_time', 'shot_deflected', 'shot_technique', 'shot_type'
]

# Columnas numéricas
numeric_cols = ['distance', 'angle']

st.subheader("Haz clic en el campo para registrar el disparo")

# Cargar imagen del campo
campo = Image.open("campo.png")

st.subheader("Haz clic sobre el campo para registrar el disparo")

# Canvas interactivo
canvas_result = st_canvas(
    fill_color="red",
    stroke_width=0,
    stroke_color="red",
    background_image=campo,
    update_streamlit=True,
    height=470,
    width=700,
    drawing_mode="point",
    key="canvas"
)

# Procesar clic
if canvas_result.json_data and canvas_result.json_data["objects"]:
    punto = canvas_result.json_data["objects"][-1]
    rel_x = punto["left"] / 700  # ancho real del canvas
    rel_y = punto["top"] / 470   # alto real del canvas

    # Convertir a escala StatsBomb (x: 0–120, y: 0–80)
    x = int(rel_x * 120)
    y = int(rel_y * 80)

    st.success(f"Disparo en X = {x}, Y = {y}")
else:
    st.warning("Haz clic sobre el campo para registrar el disparo.")
    st.stop()

# Boleanos
under_pressure = st.checkbox("Bajo presión")
one_on_one = st.checkbox("Uno contra uno")
open_goal = st.checkbox("Portería vacía")
aerial_won = st.checkbox("Remate aéreo ganado")
first_time = st.checkbox("Disparo de primeras")
deflected = st.checkbox("Desviado")

# Calcular distancia y ángulo
goal_x, goal_y = 120, 40
distance = np.sqrt((goal_x - x)**2 + (goal_y - y)**2)

def calcular_angulo(x, y):
    left_post = np.array([120, 34])
    right_post = np.array([120, 46])
    shot_point = np.array([x, y])
    v1 = left_post - shot_point
    v2 = right_post - shot_point
    cos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))
    angle_rad = np.arccos(np.clip(cos_angle, -1.0, 1.0))
    return np.degrees(angle_rad)

angle = calcular_angulo(x, y)

# DataFrame de entrada
input_df = pd.DataFrame([{
    'shot_body_part': body_part,
    'play_pattern': play_pattern,
    'under_pressure': str(under_pressure),
    'shot_one_on_one': str(one_on_one),
    'shot_open_goal': str(open_goal),
    'shot_aerial_won': str(aerial_won),
    'shot_first_time': str(first_time),
    'shot_deflected': str(deflected),
    'shot_technique': shot_technique,
    'shot_type': shot_type
}])

# Codificar categóricas
X_cat = encoder.transform(input_df)
X_cat_df = pd.DataFrame(X_cat, columns=encoder.get_feature_names_out(), index=input_df.index)

# Añadir numéricas
X_num = pd.DataFrame([[distance, angle]], columns=numeric_cols)
X_final = pd.concat([X_num, X_cat_df], axis=1)

# Alinear columnas con el modelo
expected_features = modelo.get_booster().feature_names
for col in expected_features:
    if col not in X_final.columns:
        X_final[col] = 0.0
X_final = X_final[expected_features]

# Predecir
pred_xg = modelo.predict(X_final)[0]
st.success(f"xG estimado: **{pred_xg:.3f}**")
