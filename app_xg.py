# -*- coding: utf-8 -*-
"""app_xG.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/155aDzN1xZLSOGu_wgLtDzAxF9Daup2dK
"""

#!pip install streamlit

import streamlit as st
import pandas as pd
import numpy as np
import joblib
from xgboost import XGBRegressor

# Cargar modelo y encoder
modelo = joblib.load("modelo_prueba.pkl")
encoder = joblib.load("encoder_ohe.pkl")

st.title("Calculadora de xG")

# Columnas categ√≥ricas en orden
categorical_cols = [
    'shot_body_part', 'play_pattern', 'under_pressure',
    'shot_one_on_one', 'shot_open_goal', 'shot_aerial_won',
    'shot_first_time', 'shot_deflected', 'shot_technique', 'shot_type'
]

# Columnas num√©ricas
numeric_cols = ['distance', 'angle']

# Inputs del usuario
x = st.slider("Coordenada X del disparo (0 a 120)", 0, 120, 100)
y = st.slider("Coordenada Y del disparo (0 a 80)", 0, 80, 40)

body_part = st.selectbox("Parte del cuerpo", ["Right Foot", "Left Foot", "Head", "Other"])
play_pattern = st.selectbox("Tipo de jugada", [
    'Regular Play', 'From Free Kick', 'From Throw In', 'From Corner',
    'From Counter', 'From Goal Kick', 'From Keeper', 'From Kick Off', 'Other'
])
shot_type = st.selectbox("Tipo de disparo", ['Open Play', 'Free Kick', 'Corner'])

shot_technique = st.selectbox("T√©cnica", [
    'Normal', 'Half Volley', 'Volley', 'Lob',
    'Overhead Kick', 'Diving Header', 'Backheel'
])

# Boleanos
under_pressure = st.selectbox("¬øBajo presi√≥n?", ["False", "True"])
one_on_one = st.selectbox("¬øUno contra uno?", ["False", "True"])
open_goal = st.selectbox("¬øPorter√≠a vac√≠a?", ["False", "True"])
aerial_won = st.selectbox("¬øRemate a√©reo ganado?", ["False", "True"])
first_time = st.selectbox("¬øDisparo de primeras?", ["False", "True"])
deflected = st.selectbox("¬øDesviado?", ["False", "True"])

# Calcular distancia y √°ngulo
goal_x, goal_y = 120, 40
distance = np.sqrt((goal_x - x)**2 + (goal_y - y)**2)

def calcular_angulo(x, y):
    left_post = np.array([120, 34])
    right_post = np.array([120, 46])
    shot_point = np.array([x, y])
    v1 = left_post - shot_point
    v2 = right_post - shot_point
    cos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))
    angle_rad = np.arccos(np.clip(cos_angle, -1.0, 1.0))
    return np.degrees(angle_rad)

angle = calcular_angulo(x, y)

# DataFrame de entrada
input_df = pd.DataFrame([{
    'shot_body_part': body_part,
    'play_pattern': play_pattern,
    'under_pressure': str(under_pressure),
    'shot_one_on_one': str(one_on_one),
    'shot_open_goal': str(open_goal),
    'shot_aerial_won': str(aerial_won),
    'shot_first_time': str(first_time),
    'shot_deflected': str(deflected),
    'shot_technique': shot_technique,
    'shot_type': shot_type
}])

# Codificar categ√≥ricas
X_cat = encoder.transform(input_df)
X_cat_df = pd.DataFrame(X_cat, columns=encoder.get_feature_names_out(), index=input_df.index)

# A√±adir num√©ricas
X_num = pd.DataFrame([[distance, angle]], columns=numeric_cols)
X_final = pd.concat([X_num, X_cat_df], axis=1)

# Alinear columnas con el modelo
expected_features = modelo.get_booster().feature_names
for col in expected_features:
    if col not in X_final.columns:
        X_final[col] = 0.0
X_final = X_final[expected_features]

# DEBUG: Mostrar info antes de predecir
st.write("üß™ Distancia calculada:", round(distance, 2))
st.write("üß™ √Ångulo calculado:", round(angle, 2))
st.write("üß™ Primeras columnas de entrada al modelo:")
st.write(X_final.iloc[:, :10])  # solo primeras 10 para no saturar

# Predecir
pred_xg = modelo.predict(X_final)[0]
st.success(f"xG estimado: **{pred_xg:.3f}**")
